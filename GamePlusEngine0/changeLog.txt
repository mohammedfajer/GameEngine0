

Engine
	[X] Orthographic Camera
	[x] InputManager
    [x] Components
    [X] GameObjects
	[] Entity Component System
	[X] Scene
	[] Scene Graph
	[X] Scene Manager
		[]- State Machine
	
	[x] Tiles and Tilemap
	[x] Camera System (follow player)
    [] Player Shooting Ability
	[] Build Few Levels, Doors, Scene Transition Effects
	[] Integrate ImGui

	[x] Texture Atlasing
	[] Animation System
	- Camera Shake
	[x] Movement (Follow Player)
	
	[] Resource Manager / Asset Manager
	[] Profiling
	[] Rigid Body Physics
	[] Docking ImGUi
	[] Box2D physics

	

	[] Sprite Batching
	[] Particles
	[] Lights
	[] Maps and Rooms
	[] Data Structures and Algorithms
	[] Cut Scenes
	[] Text
	[] Post Processing
		- Rain
		- Fog
		- Clouds
		- Noise
	[] Multi-threading


    [] Refactor code to use spritebatching
    




	
Before Loop


	std::vector<IceEngine::Sprite> sprites;
	IceEngine::Texture2D coinTexture = IceEngine::load_texture("./data/coin.png");
	

	for (int i = 0; i < 25; ++i) {
		glm::vec2 randomPosition = IceEngine::generateRandomPosition(sprites, 0.0f, SCREEN_WIDTH, 0.0f, SCREEN_HEIGHT, 50.0f);
		sprites.push_back(IceEngine::Sprite(randomPosition, glm::vec2(50.0f, 50.0f), coinTexture.id));
	}

	IceEngine::Texture2D playerTexture = IceEngine::load_texture("./data/plane_1_pink.png");
	sprites.push_back(IceEngine::Sprite(glm::vec2(300, 350), glm::vec2(50, 50), playerTexture.id, "player"));
	

Inside Loop

	Update

	for (IceEngine::Sprite &sprite: sprites) {
			if (sprite.name != "bg" && sprite.name != "player")
			{
				auto time = SDL_GetTicks() * 0.01f;
				sprite.position.y += 0.15f * sinf(time); // Adjust the multiplier as needed
				sprite.position.x += 0.15f * sinf(time); // Adjust the multiplier as needed
				sprite.model = glm::mat4(1.0f);
				sprite.model = glm::translate(sprite.model, glm::vec3(sprite.position, 0.0f));
				sprite.model = glm::scale(sprite.model, glm::vec3(sprite.scale, 1.0f));
			}

			if (sprite.name == "player") {

				const float speed = 50; // Adjust the speed as needed
				auto time = SDL_GetTicks() * 0.01f;
				static const Uint8* prevKeyboardState = nullptr;
				bool move = false;
				// Check for key releases
				if (prevKeyboardState) {
					if (!prevKeyboardState[SDL_SCANCODE_W] && keyboardState[SDL_SCANCODE_W]) {
						// Key W released
						 move = false;
					}
					if (!prevKeyboardState[SDL_SCANCODE_S] && keyboardState[SDL_SCANCODE_S]) {
						// Key S released
						move = false;
					}
					if (!prevKeyboardState[SDL_SCANCODE_A] && keyboardState[SDL_SCANCODE_A]) {
						// Key A released
						move = false;
					}
					if (!prevKeyboardState[SDL_SCANCODE_D] && keyboardState[SDL_SCANCODE_D]) {
						// Key D released
						move = false;
					}
				}

				SDL_GameController *gameController = NULL;
				for(int i=0; i<SDL_NumJoysticks(); i++) {
					if(SDL_IsGameController(i)) {
						gameController = SDL_GameControllerOpen(i);
						if(gameController) {
							break;
						}
					}
				}

				if(gameController) {
					float horizontalMovement = SDL_GameControllerGetAxis(gameController,SDL_CONTROLLER_AXIS_LEFTX)/32767.0f;
					float threshold = 0.2f;

					IceEngine::InputManager &input = IceEngine::InputManager::Instance();
					
					if(horizontalMovement < -threshold) {
					
					}

					if (input.IsGamepadButtonDown(SDL_CONTROLLER_BUTTON_A)) {
						sprite.position.x -= speed * 0.016f;
					}
				}


				if (keyboardState[SDL_SCANCODE_W]) {
					sprite.position.y -= speed * 0.016f;
					move = true;
				}
				if (keyboardState[SDL_SCANCODE_S]) {
					sprite.position.y += speed * 0.016f;
					move = true;
				}
				if (keyboardState[SDL_SCANCODE_A]) {
					sprite.position.x -= speed * 0.016f;
					move = true;
				}
				if (keyboardState[SDL_SCANCODE_D]) {
					sprite.position.x += speed * 0.016f;
					move = true;
				}

				sprite.rotation = -180;
				
				if(!move) sprite.position.y += 0.55f * sinf(time); // Adjust the multiplier as needed
				sprite.model = glm::mat4(1.0f);
				sprite.model = glm::translate(sprite.model, glm::vec3(sprite.position, 0.0f));
				sprite.model = glm::rotate(sprite.model, glm::radians(sprite.rotation), glm::vec3(0.0, 0.0, 1.0f));
				if(sprite.scale.x > 0) sprite.scale.x *= -1;
				sprite.model = glm::scale(sprite.model, glm::vec3(sprite.scale, 1.0f));

				prevKeyboardState = keyboardState;
			}
		}
		//camera.zoom += 0.005f * sinf(SDL_GetTicks() * 0.001f);



	// Runder

		for (const auto& sprite: sprites) {
			// Pass matrices to the shader
			shader.use();
			shader.set_mat4("projection", projection);
			shader.set_mat4("view", view);
			shader.set_mat4("model", sprite.model);

			glBindTexture(GL_TEXTURE_2D, sprite.texture);
			glBindVertexArray(VAO);
			glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
		}
	



		IceEngine::InputManager::Instance().Update();

		glm::vec2 position = IceEngine::InputManager::Instance().GetMousePosition();
		IceEngine::Logger::Instance().Log("Mouse Pos = (" + std::to_string(position.x) + "," + std::to_string(position.y) + ")");


		float deltaTime = IceEngine::Timer::Instance().Tick();

		// calculate FPS
		float FPS = 1.0f / deltaTime;

		IceEngine::Logger::Instance().Log("FPS : " + std::to_string(FPS), IceEngine::LogLevel::INFO); 

		// Get the current state of the keyboard
		const Uint8* keyboardState = SDL_GetKeyboardState(NULL);

		glm::mat4 projection = camera.projection;
		glm::mat4 view = camera.get_view_matrix();

		

		// Rendering code goes here
		IceEngine::set_clear_color({ 73, 130, 55, 255 });
		glClear(GL_COLOR_BUFFER_BIT);



------------------------------

